"""This script is based on a skeleton https script provided by kaspersky GReAt.
This version is a simple http server which is
 - going to get all the coockies received in Get Requests and print them
 - return a simple web page which contains the words "the response from the c2, related to the cookies
 - test the crypto stuff to undersatnd which info is return by the C2
 - simulate info from C2 to the malware"""
##################################################
########        WHY this script?          ########
""" As the server have been seized, create a c2 server with a python script.
- change the c2 server in sunshuttle: open sunshuttle sample with 010 editor,
look for the c2 server as a string, and replace the malicious domain name by another one that we control
(downgrading from https to http in order to avoid SSL certificate settings, and respecting the size of the original string.
Cf. structure of string in go), for instance replace https://nikeoutletinc.org by http://localhost:8888/aaa"""

import http.server
import sys
import http.cookies
import base64
from Crypto.Cipher import PKCS1_OAEP, AES
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA

HOSTNAME = "localhost"
PORT = 8000

# Generate by obtaining the private key inside the binary,
# change "BEGIN PRIVATE KEY" to "BEGIN RSA PRIVATE KEY" and "END PRIVATE KEY" to END RSA PRIVATE KEY,
# then openssl rsa -in /tmp/privkey, then  openssl rsa -in /tmp/privkey -pubout
RSA_PUBKEY = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9wOBAQEFAAOCAQ8AMIIBCgKCAQEAyJvFK31BlKxKaDQOKbID
LAa31hMwIEZmgI4/oOu5+YaDAifAYnpOQJWPV194h5kousFJK+UOyLOh6WeQFR/6
LiPic6TeejO8vNwZyor+mzuah7KZwIxwOLDdl5glxZ6N7e2+/PWomMCld2Mn4UQy
sWuHk5UVZPwAtD+020s2MaejShR2WANJssJyuG21vpEzU3pZYc4PQVNZBs04dfXx
A34uA4Aes3HgCK+lx/d46bDhRwKKg+YncKxEt/zskSEiyQ/od50JDBmex9x0VZnH
hLv37POioWXGO3gztPKaB/tLtZmLclQUIkT//PEFjYSsQyN513fz+J5neC0L8eMM
XwIDAQAB
-----END PUBLIC KEY-----"""

SESSION_KEY = b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

def rsa_oaep_encrypt(data):
    key = RSA.importKey(RSA_PUBKEY)
    cipher = PKCS1_OAEP.new(key, hashAlgo=SHA256) #we notice the hash algo because by default, OAEP use SHA1. [64B8ED]
    return cipher.encrypt(data)

#nww function to send data to the malware; we need the AES cypher to do that
def aes_encrypt(data):
    cipher = AES.new(SESSION_KEY, AES.MODE_CFB, segment_size=128)#6443BB. CFB has a segment size. By default, it's 8 but in GO it's 128
    #encrypted = cipher.iv + cipher.encrypt(data)
    # 1) --> warning from the stackoverflow.com forum:
    # "Also, aes-256-cfb uses the IV only in the first encrypted block, which means if you are using a random IV, only the first block (the first 128 bits)
    # of the data will be decrypted wrongly. Everything starting from the second block should decrypt just fine"
    #source: https://stackoverflow.com/questions/60949908/encryption-decryption-aes-256-cfb-in-python
    #we have to be sure that the data will be decoded properly from base64 with the URL encoding cf.644338
    #base64.urlsafe_b64encode(encrypted)
    #the input data actually might not be the correct size to be encrypted. pits size might not be a multiple of 16. So we need to add some PKCS#7 padding
    #sources:https://stackoverflow.com/questions/12524994/encrypt-decrypt-using-pycrypto-aes-256 / https://github.com/JeffDeCola
    encrypted = cipher.iv + cipher.encrypt(pad(data))
    return encrypted
    #encrypted = b"WHATEVER" + base64.b64encode(base64.urlsafe_b64encode(cipher.iv + cipher.encrypt(pad(order))))


def pad(m): #PKCS#7
    return m + (chr(16 - len(m) % 16) * (16 - len(m) % 16)).encode()
    # source:  https://stackoverflow.com/questions/43199123/encrypting-with-aes-256-and-pkcs7-padding?rq=1


class SunshuttleHandler(http.server.BaseHTTPRequestHandler):
    def do_Get(self):
        # Add your code here
        """going to get all the coockies received in Get Requests and print them """
        cookies = http.cookies.SimpleCookie(self.headers.get('Cookie')) # get cookies

        """let's put the 'Respond to a Get request' block here because the headers should sent before
         we start to write to the page"""
        self.send_response(200)
        self.send_header("content-type", "text/html")
        self.end_headers() #all received
        #self.wfile.write(b"yugDtwEGuR")#  offset 647547 and 657556 ASSCI char reversed because endianless
        #"yugDtwEGuR" will appear in the ret value of the x64dbg at offset 6474f6, sunshuttle.io_ioutil.readAll function.
        #and at offset 64753F we have the comparison with the string size, and as the size match, the jmp is not taken
        # and ret value at 64B7Be will be 1

        """"We need to return different values depending on the cookie we receive"""
        if "GC6BzibvrlkYoFr" in cookies:
            if cookies["GC6BzibvrlkYoFr"].value == "uWrGEdYLq":
                print("Received a session key generation request!")
                self.wfile.write(b"yugDtwEGuR")
            elif cookies["GC6BzibvrlkYoFr"].value == "3qnehpTGrqr9x":
                print("Received a session key retrieval request!")
                self.wfile.write(base64.b64encode(rsa_oaep_encrypt(SESSION_KEY))# replace this key (b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"))) by the variable SESSION_KEY
            else:
                print("Error - Unsupported request")
                print(cookies, "\r\n")

        else:
            print("Request without the expected cookie!")
            print(cookies, "\r\n")
            #self.wfile.write(b"WHATEVER*MAN")#try with an "*" to check what is happening at 647Fb2 with this *,
            # and press F9 when you are at 647F20. if the program crash--> ctrl+F2 and start again. At the
            # 647F20, "WHATEVER" will appear, and then, at the 647FB7, the second part of the string [the 2nd token] "MAN" will
            # appear in RBX. this 2nd token should be the one that it will be decoded with base64.
            # You could replace man with base64 characters and try again, to verify.
            """main_beconing function reached! [64BAF1] and then main_decrypt reached."""
            self.wfile.write(b"WHATEVER*" + base64.b64encode(aes_encrypt(b"MAN"))) #WHATEVER is replaced with smthg that main_decrypt fun can handle
        sys.stdout.flush()

"""in order to we try to understand what it happen at the block 644380, we add a new python function, at the top, that is going to allow us to send data to the malware"""


def run(server_class=http.server.HTTPServer, handler_class=SunshuttleHandler):
    server_address = (HOSTNAME, PORT)
    httpd = server_class(server_address, handler_class)
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("Bye!")

if __name__ == '__main__':
    run()

"""with this script, we are able to encrypt orders and have them sent from the c2 to the backdoor, and the decoding took place as expected"""
"""now we can get out of this function and come back just after the decryption took place at 6480B9, in x64dbg"""

