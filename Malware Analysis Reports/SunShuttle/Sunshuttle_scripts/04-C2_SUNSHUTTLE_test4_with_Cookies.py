"""This script is based on a skeleton https script provided by kaspersky GReAt.
This version is a simple http server which is
 - going to get all the coockies received in Get Requests and print them
 - return a simple web page which contains the words "the response from the c2, related to the cookies"""
##################################################
########        WHY this script?          ########
""" As the server have been seized, create a c2 server with a python script.
- change the c2 server in sunshuttle: open sunshuttle sample with 010 editor,
look for the c2 server as a string, and replace the malicious domain name by another one that we control
(downgrading from https to http in order to avoid SSL certificate settings, and respecting the size of the original string.
Cf. structure of string in go), for instance replace https://nikeoutletinc.org by http://localhost:8888/aaa"""

import http.server
import sys
import http.cookies

HOSTNAME = "localhost"
PORT = 8000

class SunshuttleHandler(http.server.BaseHTTPRequestHandler):
    def do_Get(self):
        # Add your code here
        """going to get all the coockies received in Get Requests and print them """
        cookies = http.cookies.SimpleCookie(self.headers.get('Cookie')) # get cookies

        """let's put the 'Respond to a Get request' block here because the headers should sent before we start to write to the page"""
        self.send_response(200)
        self.send_header("content-type", "text/html")
        self.end_headers() #all received
        #self.wfile.write(b"yugDtwEGuR")#  offset 647547 and 657556 ASSCI char reversed because endianless
        #"yugDtwEGuR" will appear in the ret value of the x64dbg at offset 6474f6, sunshuttle.io_ioutil.readAll function.
        #and at offset 64753F we have the comparison with the string size, and as the size match, the jmp is not taken
        # and ret value at 64B7Be will be 1

        """"We need to return different values depending on the cookie we receive"""
        if cookie[GC6BzibvrlkYoFr].value == "uWrGEdYLq"
            print("Received a session key request!")
            self.wfile.write(b"yugDtwEGuR")
        elif cookies["GC6BzibvrlkYoFr"].value = "3qnehpTGrqr9x":
            print("Received a retrieved session key request!")
            self.wfile.write(b"AAAAAAAAAAAAAAAAAAAAAAAAAAAA") #we don't know how it will be handled, so let's try with random characters
        else
            print("Error - Unsupported request")
            print(cookies, "\r\n")
        sys.stdout.flush()

def run(server_class=http.server.HTTPServer, handler_class=SunshuttleHandler):
    server_address = (HOSTNAME, PORT)
    httpd = server_class(server_address, handler_class)
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("Bye!")

if __name__ == '__main__':
    run()
"""With this script, we reach offset 64B788 and take the direction of the main_retrieve_session_key function offest 64b*16"""
"""put a bp to the readAll fun offset 647E2A, in x64dbg - f9 -a little bit of execution delay because of the 5-15sec random sleeps
and we will receive the response from the c2 in our powershell windows"""
"""Then press f8 in x64dbg and 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' will appear and if we continue to step over, 
our fun ret value AAAA will be convert into str and put in rsp (64B820) =size of the str?
This path reach the 64BCB7 lock and after many cmp, reach a crypto block at the offset 64B8CB. 
-->Try another implement this crypto stuffs in another script""""


