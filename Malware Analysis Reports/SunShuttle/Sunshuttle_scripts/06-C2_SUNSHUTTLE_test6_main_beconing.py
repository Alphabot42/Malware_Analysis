"""This script is based on a skeleton https script provided by kaspersky GReAt.
This version is a simple http server which is
 - going to get all the coockies received in Get Requests and print them
 - return a simple web page which contains the words "the response from the c2, related to the cookies"""
##################################################
########        WHY this script?          ########
""" As the server have been seized, create a c2 server with a python script.
- change the c2 server in sunshuttle: open sunshuttle sample with 010 editor,
look for the c2 server as a string, and replace the malicious domain name by another one that we control
(downgrading from https to http in order to avoid SSL certificate settings, and respecting the size of the original string.
Cf. structure of string in go), for instance replace https://nikeoutletinc.org by http://localhost:8888/aaa"""

import http.server
import sys
import http.cookies
import base64
from Crypto.Cipher import PKCS1_OAEP,
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA



HOSTNAME = "localhost"
PORT = 8000

# Generate by obtaining the private key inside the binary,
# change "BEGIN PRIVATE KEY" to "BEGIN RSA PRIVATE KEY" and "END PRIVATE KEY" to END RSA PRIVATE KEY,
# then openssl rsa -in /tmp/privkey, then  openssl rsa -in /tmp/privkey -pubout
RSA_PUBKEY = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9wOBAQEFAAOCAQ8AMIIBCgKCAQEAyJvFK31BlKxKaDQOKbID
LAa31hMwIEZmgI4/oOu5+YaDAifAYnpOQJWPV194h5kousFJK+UOyLOh6WeQFR/6
LiPic6TeejO8vNwZyor+mzuah7KZwIxwOLDdl5glxZ6N7e2+/PWomMCld2Mn4UQy
sWuHk5UVZPwAtD+020s2MaejShR2WANJssJyuG21vpEzU3pZYc4PQVNZBs04dfXx
A34uA4Aes3HgCK+lx/d46bDhRwKKg+YncKxEt/zskSEiyQ/od50JDBmex9x0VZnH
hLv37POioWXGO3gztPKaB/tLtZmLclQUIkT//PEFjYSsQyN513fz+J5neC0L8eMM
XwIDAQAB
-----END PUBLIC KEY-----"""

def rsa_oaep_encrypt(data):
    key = RSA.importKey(RSA_PUBKEY)
    cipher = PKCS1_OAEP.new(key, hashAlgo=SHA256) #we notice the hash algo because by default, OAEP use SHA1. [64B8ED]
    return cipher.encrypt(data)


class SunshuttleHandler(http.server.BaseHTTPRequestHandler):
    def do_Get(self):
        # Add your code here
        """going to get all the coockies received in Get Requests and print them """
        cookies = http.cookies.SimpleCookie(self.headers.get('Cookie')) # get cookies

        """let's put the 'Respond to a Get request' block here because the headers should sent before
         we start to write to the page"""
        self.send_response(200)
        self.send_header("content-type", "text/html")
        self.end_headers() #all received
        #self.wfile.write(b"yugDtwEGuR")#  offset 647547 and 657556 ASSCI char reversed because endianless
        #"yugDtwEGuR" will appear in the ret value of the x64dbg at offset 6474f6, sunshuttle.io_ioutil.readAll function.
        #and at offset 64753F we have the comparison with the string size, and as the size match, the jmp is not taken
        # and ret value at 64B7Be will be 1

        """"We need to return different values depending on the cookie we receive"""
        if "GC6BzibvrlkYoFr" in cookies:
            if cookies["GC6BzibvrlkYoFr"].value == "uWrGEdYLq":
                print("Received a session key generation request!")
                self.wfile.write(b"yugDtwEGuR")
            elif cookies["GC6BzibvrlkYoFr"].value == "3qnehpTGrqr9x":
                print("Received a session key retrieval request!")
                self.wfile.write(base64.b64encode(rsa_oaep_encrypt((b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")))
            else:
                print("Error - Unsupported request")
                print(cookies, "\r\n")

        else:
            print("Request without the expected cookie!")
            print(cookies, "\r\n")
            #self.wfile.write(b"WHATEVER")
            self.wfile.write(b"WHATEVER*MAN")#try with an "*" to check what is happening at 647Fb2 with this *,
            # and press F9 when you are at 647F20. if the program crash--> ctrl+F2 and start again. At the
            # 647F20, "WHATEVER" will appear, and then, at the 647FB7, the second part of the string [the 2nd token] "MAN" will
            # appear in RBX. this 2nd token should be the one that it will be decoded with base64.
            # You could replace man with base64 characters and try again, to verify.
        sys.stdout.flush()

def run(server_class=http.server.HTTPServer, handler_class=SunshuttleHandler):
    server_address = (HOSTNAME, PORT)
    httpd = server_class(server_address, handler_class)
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("Bye!")

if __name__ == '__main__':
    run()
"""With this script [we added the def rsa_oaep_encrypt(data) function], we reach offset 647E34  
   and we can see in 647E2F offset, that our input was encoded with base64.
nb. if we remove the others bp and run until return, we go back to the offset 64B81B, just after our main_retrieve_session_key
put a bp here, and skip over and we reach the 64B8ED where SHA256 is being created
skip over it and we reach base64 encoding at 64B915, then some stuffs which they have to be the RSA cipher parsing, 
and then the private key 64B9AA, and the decrypt function 64BA24, F8, and at the following offset 64BA29 our input is in RAX. The decoded bytes will be in RDX """

"""main_beconing function reached! [64BAF1]"""


